<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
</head>
<body style="margin:0;">
<canvas id="main-canvas" width="1920" height="1076"></canvas>
<script type="text/javascript">
    let base = Math.pow(2, 1/12);
    const EPSILON = 1e-6;
    let maxMultiplier = 10;
    let pureMode = false;
    let intervalOffset1 = 0;
    let intervalOffset2 = 0;

    let mainChord;

    document.addEventListener('keydown', (e) => {
        if (e.code.startsWith('Digit')) {
            maxMultiplier = 10 + parseInt(e.code[5]);
            setMainChord();
        }
        if (e.code == 'KeyP') {
            pureMode = !pureMode;
            setMainChord();
        }
        if (e.code == 'KeyB') {
            base *= 1.00005;
            setMainChord();
        }
        if (e.code == 'KeyV') {
            base /= 1.00005;
            setMainChord();
        }
        if (e.code == 'NumpadMultiply') {
            intervalOffset1 += 6;
            prevX += 6;
            setMainChord();
        }
        if (e.code == 'NumpadDivide' && intervalOffset1 > 0) {
            intervalOffset1 -= 6;
            prevX -= 6;
            setMainChord();
        }
        if (e.code == 'NumpadAdd') {
            intervalOffset2 += 12;
            prevY += 12;
            setMainChord();
        }
        if (e.code == 'NumpadSubtract' && intervalOffset2 > 0) {
            intervalOffset2 -= 12;
            prevY -= 12;
            setMainChord();
        }
        // TODO: Trigger mainChord recalculation on offset change
    });

    function pureError(intervals) {
        let error = 0;
        for (let i of intervals) {
            error += Math.abs(Math.log(i) - Math.log(Math.round(i)));
        }
        return error;
    }

    // Balance out the "movement" of a group of notes.
    function nudgeIntervals(intervals) {
        let correction = 1;
        for (let i of intervals) {
            correction *= i / Math.round(i);
        }
        return intervals.map(i => i * Math.pow(correction, -1 / intervals.length));
    }

    // Try to find the least "moving" representation of a group of notes.
    // If the none of the intervals is an integer this may produce weird results.
    function fiddleIntervals(intervals) {
        let bestError = Infinity;
        let best = intervals;
        for (let multiplier = 1; multiplier < maxMultiplier+1; multiplier++) {
            const fiddled = nudgeIntervals(intervals.map(i => i * multiplier));
            const error = pureError(fiddled);
            if (error + EPSILON < bestError) {
                bestError = error;
                best = fiddled;
            }
        }
        if (pureMode) {
            return nudgeIntervals(best.map(i => Math.round(i)));
        }
        return best;
    }

    let prevX = 4;
    let prevY = 7;
    function setMainChord() {
        const mainChordUnfiddled = [1, Math.pow(base, prevX), Math.pow(base, prevY)];
        mainChord = fiddleIntervals(mainChordUnfiddled);
        if (pureMode) {
            mainChord = mainChord.map(i => i + Math.random()*0.01);
            mainChord = nudgeIntervals(mainChord);
        }
    }
    setMainChord();

    document.addEventListener('mousemove', (e) => {
        if (e.pageX > 1080) {
            let x = (e.pageX - 1076) / (1920 - 1080);
            x = Math.floor(11*x) + intervalOffset1 + 1;
            let y = e.pageY / (1920 - 1080);
            y = Math.floor(11*y) + intervalOffset2 + 2;
            if (y >= x && (x != prevX || y != prevY)) {
                prevX = x;
                prevY = y;
                setMainChord();
            }
        }
    });

    const strokeStyles = ["#220203", "#022203", "#010133", "#201502", "#200220", "#032223"];
    const sumStrokeStyle = "#160621";

    const mainCanvas = document.getElementById("main-canvas");
    const ctx = mainCanvas.getContext("2d");

    function leftSideView() {
        ctx.translate(mainCanvas.height/2, mainCanvas.height/2);
        ctx.scale(0.5*mainCanvas.height, 0.5*mainCanvas.height);
        ctx.lineWidth = 5/mainCanvas.height;
    }

    function rightSideBox(x, y, width) {
        const delta = mainCanvas.height*0.77 / width;
        ctx.translate(mainCanvas.height + (x+0.5)*delta, (y+.5)*delta);
        ctx.scale(delta, delta);
        ctx.lineWidth = 3/mainCanvas.height;
    }

    let mainOffset = 0;
    let boxOffset = 0;
    let accuracy = 1000;
    const arcLenght = Math.PI * 2;


    function drawChord(chord, drawSum=true, offset) {
        const mu = arcLenght / accuracy;

        let n = 0;
        for (let interval of chord) {
            ctx.beginPath();
            for (let i = 0; i < accuracy + 1; i++) {
                const theta = i * mu + offset;
                let r = Math.pow(Math.cos(interval * theta), 9);
                r = 0.05 * (4 + 2.2*n + r);
                const x = Math.cos(theta) * r;
                const y = Math.sin(theta) * r;
                if (i == 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = strokeStyles[n];
            ctx.stroke();
            n += 1;
        }

        if (drawSum) {
            ctx.beginPath();
            for (let i = 0; i < accuracy + 1; i++) {
                const theta = i * mu + offset;
                let r = 0;
                for (interval of chord) {
                    r += Math.pow(Math.cos(interval * theta), 9);
                }
                r = 0.05 * (7 + 2.2*n + r);
                const x = Math.cos(theta) * r;
                const y = Math.sin(theta) * r;
                if (i == 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = sumStrokeStyle;
            ctx.stroke();
        }
    }


    INTERVALS = {
        0: "P1",
        1: "m2",
        2: "M2",
        3: "m3",
        4: "M3",
        5: "P4",
        6: "A4",
        7: "P5",
        8: "m6",
        9: "M6",
        10: "m7",
        11: "M7",
        12: "P8",
    };
    function getIntervalName(interval) {
        if (interval < 0) {
            return "-" + getIntervalName(-interval);
        }
        let shift = 0;
        for (let i = 0; i < 10; ++i) {
            const name = INTERVALS[interval];
            if (name !== undefined) {
                const size = parseInt(name[1]) + shift
                return name[0] + size;
            }
            interval -= 12;
            shift += 8;
        }
        return "?";
    }
    CHORDS = {
        "0,7": "5",
        "2,7": "sus2",
        "3,6": "Â°",
        "3,7": "m",
        "3,10": "m7",
        "4,7": "M",
        "4,8": "+",
        "4,10": "7",
        "4,11": "M7",
        "5,7": "sus4",
        "7,7": "5",
    }
    function getPlainChordName(intervals) {
        let name = CHORDS[intervals.join(",")];
        if (name !== undefined) {
            return name;
        }
        name = CHORDS[(12 - intervals[1]) + "," + (intervals[0] + 12 - intervals[1])];
        if (name !== undefined) {
            return name;
        }
        name = CHORDS[(intervals[1] - intervals[0]) + "," + (12 - intervals[0])];
        if (name !== undefined) {
            return name;
        }
    }
    function getChordName(intervals) {
        let name = CHORDS[intervals.join(",")];
        if (name !== undefined) {
            return name;
        }
        name = CHORDS[(12 - intervals[1]) + "," + (intervals[0] + 12 - intervals[1])];
        if (name !== undefined) {
            return name + " (first inversion)";
        }
        name = CHORDS[(intervals[1] - intervals[0]) + "," + (12 - intervals[0])];
        if (name !== undefined) {
            return name + " (second inversion)";
        }
        if (intervals[1] >= 12) {
            if (intervals[0] >= 12) {
                name = getPlainChordName([intervals[0] - 12, intervals[1] - 12]);
                if (name !== undefined) {
                    return name + " (open voicing)";
                }
            } else {
                name = getPlainChordName([intervals[1] - 12, intervals[0]]);
                if (name !== undefined) {
                    return name + " (open voicing)";
                }
                name = getPlainChordName([intervals[0], intervals[1] - 12]);
                if (name !== undefined) {
                    return name + " (open voicing)";
                }
            }
        }
        return "";
    }
    function drawStatus() {
        ctx.font = "30px Arial";
        ctx.fillText("Chord: " + getIntervalName(prevX) + " " + getIntervalName(prevY), 20, 40);
        ctx.fillText("Name: " + getChordName([prevX, prevY]), 20, 80);
        let error = pureError(mainChord);
        ctx.fillText("Error: " + Math.round(error * 100000), 20, 120);
    }


    ctx.save();
    let iteration = 0;
    function update() {
        ctx.restore();
        ctx.save();
        // if (iteration % 100 == -1) {
        //     ctx.globalCompositeOperation = "lighter";
        //     ctx.fillStyle = "rgba(255,255,255,0.001)";
        // } else {
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        //}
        ctx.fillRect(0,0,mainCanvas.height,mainCanvas.height);
        if (iteration % 3 == 0) {
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.fillRect(mainCanvas.height,0, mainCanvas.height, mainCanvas.height);
        }
        ctx.globalCompositeOperation = "source-over";

        ctx.fillStyle = "#000000";
        drawStatus();

        accuracy = 2000;
        leftSideView();
        drawChord(mainChord, true, mainOffset);
        ctx.restore();
        ctx.save();

        if (iteration % 3 == 0) {
            accuracy = 200;
            for (let b = 1+intervalOffset1; b < 12+intervalOffset1; b++) {
                for (let c = Math.max(b, 2+intervalOffset2); c < 16+intervalOffset2; c++) {
                    rightSideBox(b - 1 - intervalOffset1 , c - 2 - intervalOffset2, 11);
                    const chord = fiddleIntervals([1, Math.pow(base, b), Math.pow(base, c)]);
                    drawChord(chord, false, boxOffset);
                    ctx.restore();
                    ctx.save();
                }
            }
            boxOffset += arcLenght;
        }

        mainOffset += arcLenght;
        iteration += 1;
    }

    window.setInterval(update, 1000 / 60);


    const audioCtx = new AudioContext();
    audioCtx.suspend();

    const DT = 1 / audioCtx.sampleRate;

    function makeSoftBuzzPeriodicWave(context, softness=0.1) {
      // TODO: Dynamically calculate number of needed harmonics for sharp sounds.
      const nHarmonics = 256;
      const real = new Float32Array(nHarmonics);
      const imag = new Float32Array(nHarmonics);

      real[0] = 0;
      imag[0] = 0;
      for (let i = 1; i < nHarmonics; ++i) {
        real[i] = 0;
        imag[i] = Math.exp(-softness * i*i);
      }

      return context.createPeriodicWave(real, imag);
    }
    const buzz = makeSoftBuzzPeriodicWave(audioCtx, 0.05);
    const softBuzz = makeSoftBuzzPeriodicWave(audioCtx, 0.1);
    const softerBuzz = makeSoftBuzzPeriodicWave(audioCtx, 0.2);

    function makeSigmoidCurve() {
      const nSamples = 40000;
      const curve = new Float32Array(nSamples);

      for (let i = 0; i < nSamples; ++i) {
        let x = i - 0.5 * nSamples;
        x /= nSamples;
        x *= 10;
        curve[i] = Math.tanh(x);
      }
      return curve;
    }

    function findBaseFrequency(note) {
        const freq = Math.pow(mainChord[0] * mainChord[1] * mainChord[2], -1/3);
        const pitch = Math.log(freq) / Math.log(base);
        if (note === undefined) {
            note = Math.round(Math.random()*8-4);
        }
        return Math.pow(base, Math.round(pitch) + note) * 220;
    }

    const oscillator = audioCtx.createOscillator();
    oscillator.type = 'triangle';
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    oscillator.connect(gain).connect(audioCtx.destination);
    oscillator.start();

    const buzzers = [];
    const buzzPreGain = audioCtx.createGain();
    buzzPreGain.gain.setValueAtTime(0, audioCtx.currentTime);
    const buzzPostGain = audioCtx.createGain();
    buzzPostGain.gain.setValueAtTime(0, audioCtx.currentTime);

    const sigmoidDistortion = audioCtx.createWaveShaper();
    sigmoidDistortion.curve = makeSigmoidCurve();
    sigmoidDistortion.oversample = '4x';
    buzzPreGain.connect(sigmoidDistortion).connect(buzzPostGain).connect(audioCtx.destination);
    for (let i = 0; i < mainChord.length; ++i) {
        const buzzer = audioCtx.createOscillator();
        buzzer.setPeriodicWave(softBuzz);
        buzzer.connect(buzzPreGain);
        buzzer.start();
        buzzers.push(buzzer);
    }

    PITCHES = {
        KeyA: 0,
        KeyS: 1,
        KeyD: 2,
        KeyF: 3,
        KeyG: 4,
        KeyH: 5,
        KeyJ: 6,
        KeyK: 7,
        KeyL: 8,
        Semicolon: 9,
        Quote: 10,
        Backslash: 11,
    };

    document.addEventListener('keydown', e => {
        audioCtx.resume();  // Thanks Chrome!
        if (e.code == 'KeyQ') {
            oscillator.frequency.cancelScheduledValues(audioCtx.currentTime);
            gain.gain.cancelScheduledValues(audioCtx.currentTime);

            const freq = findBaseFrequency();
            oscillator.frequency.setValueAtTime(freq * mainChord[0], audioCtx.currentTime);
            oscillator.frequency.setValueAtTime(freq * mainChord[1], audioCtx.currentTime + 1);
            oscillator.frequency.setValueAtTime(freq * mainChord[2], audioCtx.currentTime + 2);

            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.4, audioCtx.currentTime + 0.01);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime + 3);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 3.02);
        }

        if (PITCHES[e.code] !== undefined || e.code == 'KeyR') {
            let freq = findBaseFrequency(PITCHES[e.code]);
            let preGain, postGain, wave;
            if (e.shiftKey) {
                preGain = 1;
                postGain = 0.2;
                wave = softBuzz;
            } else {
                preGain = 0.001;
                postGain = 40;
                wave = buzz;
            }
            if (e.code == 'KeyR') {
                preGain = 0.5;
                postGain = 0.2;
                freq *= 3;
                wave = softerBuzz;
            }

            for (let i = 0; i < mainChord.length; ++i) {
                const buzzer = buzzers[i];
                buzzer.setPeriodicWave(wave);
                buzzer.frequency.cancelScheduledValues(audioCtx.currentTime);
                buzzer.frequency.setValueAtTime(freq * mainChord[i], audioCtx.currentTime);
            }

            buzzPreGain.gain.cancelScheduledValues(audioCtx.currentTime);
            buzzPreGain.gain.setValueAtTime(0, audioCtx.currentTime);
            buzzPreGain.gain.linearRampToValueAtTime(preGain, audioCtx.currentTime + 0.01);
            buzzPreGain.gain.setValueAtTime(preGain, audioCtx.currentTime + 2);
            buzzPreGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2.02);

            buzzPostGain.gain.cancelScheduledValues(audioCtx.currentTime);
            buzzPostGain.gain.setValueAtTime(0, audioCtx.currentTime);
            buzzPostGain.gain.linearRampToValueAtTime(postGain, audioCtx.currentTime + 0.01);
        }
    })
</script>
</body>
</html>